# 322. Coin Change

```python
def coinChange(coins, amount):
    # Initialize a list to store the minimum number of coins needed for each amount
    ## We can also use `amount+1` instead of `float('inf')`.
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # Base case: 0 amount requires 0 coins

    for coin in coins:
        for x in range(coin, amount + 1):
            dp[x] = min(dp[x], dp[x - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1

# Example usage
coins = [1, 2, 5]
amount = 11
print(coinChange(coins, amount))  # Output: 3
```

### Approach and Trick

1. **Dynamic Programming (DP)**: We use a DP array to store the minimum number of coins needed to make each amount from `0` to `amount`.
2. **Initialization**: We initialize the DP array with infinity (`float('inf')`), except for `dp[0]` which is set to `0` because zero amount requires zero coins.
3. **Iterative Update**: For each coin, we update the DP array for all amounts that are greater than or equal to the coin's value by taking the minimum number of coins required.

### Time and Space Complexity

- **Time Complexity**: $$O(n \times m)$$, where \(n\) is the number of coins and \(m\) is the amount. This is because for each coin, we iterate through all amounts from the coin's value to the target amount.
- **Space Complexity**: $$O(m)$$, where \(m\) is the amount. This is due to the DP array which stores the minimum number of coins needed for each amount up to `amount`.
