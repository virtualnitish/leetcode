# House Robber

Sure! Here's an efficient, readable, and optimized Python solution for the **House Robber** problem:

```python
def rob(nums):
    if not nums:
        return 0

    prev_max = curr_max = 0
    for num in nums:
        # Calculate the new maximum by deciding to rob or skip the current house
        temp = curr_max
        curr_max = max(prev_max + num, curr_max)
        prev_max = temp

    return curr_max

# Example usage
houses = [2, 7, 9, 3, 1]
print(rob(houses))  # Output: 12
```

### Approach

**Dynamic Programming with Space Optimization**:

- **Idea**: At each house, decide whether to rob it (and add its value to the total from two houses back) or skip it (and carry forward the total from the previous house).
- **Implementation**:
  - Initialize two variables:
    - `prev_max`: Maximum amount that can be robbed up to the previous house.
    - `curr_max`: Maximum amount that can be robbed up to the current house.
  - Iterate through the list of house values (`nums`):
    - For each house, update `curr_max` to be the maximum of:
      - `prev_max + num` (robbing the current house).
      - `curr_max` (skipping the current house).
    - Update `prev_max` to the value of `temp` (which holds the old `curr_max`).

### Time and Space Complexity

- **Time Complexity**: `O(n)`, where `n` is the number of houses.
  - We traverse the list of houses once.
- **Space Complexity**: `O(1)`, constant space.
  - Only a fixed number of variables are used, regardless of the input size.
