# 5. Longest Palindromic Substring

```python

class Solution:
    def longestPalindrome(self, s: str) -> str:
        start, end = 0, 0
        
        for fixed in range(len(s)):
            for x in [0, 1]:  # Check for both even and odd length palindromes
                i, j = fixed - x, fixed + 1
                
                while i >= 0 and j < len(s) and s[i] == s[j]:
                    # Update the longest palindrome bounds if a longer one is found
                    if j - i > end - start:
                        start, end = i, j
                    i -= 1
                    j += 1
        
        # Return the longest palindromic substring
        return s[start:end + 1]

```

In the condition, `i, j = fixed - x, fixed + 1`, remember it as two fingers where **right finger is always at +1**,i.e., `j = fixed + 1` and the **left finger** `i` moves by `x`. 
The `i, j = fixed - x, fixed + 1` can also be replaced with `i, j = fixed, fixed + x`. 
Both works.   
This change would also accomodate the extended question: [647. Palindromic Substrings](0647.palindromic_substrings.md).

Time Complexity: O(n<sup>2</sup>)   
Space Complexity: O(1)

### How does this code handle single-character?

**Single-char fallback** comes from the initial start,end = 0,0. If no longer palindrome is found, it returns s[0:1].   

The same logic won't work with [647. Palindromic Substrings](0647.palindromic_substrings.md) because there we need to
count every single-char as a palindrome which `i, j = fixed - x, fixed + 1` condition fails to cover.   
The condition `i, j = fixed, fixed + x` does a `i, j = fixed, fixed` check for single char, 
which `i, j = fixed - x, fixed + 1` condition never does, rather it relies on `return s[start:end + 1]` to cover for a single char.
