# 4. Median of Two Sorted Arrays

```python
# Time: log(min(n, m))
## Code provided by Neetcode
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        A, B = nums1, nums2
        total = len(nums1) + len(nums2)
        half = total // 2

        if len(B) < len(A):
            A, B = B, A

        l, r = 0, len(A) - 1
        while True:
            i = (l + r) // 2  # A
            j = half - i - 2  # B

            Aleft = A[i] if i >= 0 else float("-infinity")
            Aright = A[i + 1] if (i + 1) < len(A) else float("infinity")
            Bleft = B[j] if j >= 0 else float("-infinity")
            Bright = B[j + 1] if (j + 1) < len(B) else float("infinity")

            # partition is correct
            if Aleft <= Bright and Bleft <= Aright:
                # odd
                if total % 2:
                    return min(Aright, Bright)
                # even
                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2
            elif Aleft > Bright:
                r = i - 1
            else:
                l = i + 1

```

### Notes:

The part `j = half - i - 2  # B` where we subtract `-2` can be broken into
following part:

```python
        while True:
            i = (l + r) // 2  # A
            j = half - (i+1) - 1  # B
```
The `i` and `j` are the indices. To get the value of `j`, we need to subtract 
the *length* but `i` is the position in the array so we add `1` to `i` for 
calculation.

## GPT explains


**Summary**

In this solution, we perform a binary search on the smaller array to find a partition that splits both arrays into halves where all elements on the left are less than or equal to those on the right. We calculate partition indices `i` and `j` for arrays `A` and `B`. By comparing the elements around these partitions, we adjust our search until the correct partition is found. Once found, we compute the median based on whether the total number of elements is odd or even, using the nearby elements.


**Long Explanation**

Let's dive deep into how this solution efficiently finds the median of two sorted arrays without merging them—saving precious time and space.

The crux of the algorithm is leveraging **binary search** on one array to find the perfect partition between the two arrays. This partition ensures that all elements on the left side of the partitions are less than or equal to all elements on the right side—across both arrays.

Here's the step-by-step intuition:

1. **Choosing the Smaller Array**: We start by assigning `A` and `B` to be `nums1` and `nums2`, respectively. However, we swap them if `nums1` is larger. This is crucial because we perform binary search on `A`, and we want to minimize the search space for efficiency.

2. **Setting Up Binary Search Bounds**: We initialize `l` (left) and `r` (right) to `0` and `len(A) - 1`, respectively. These pointers define our current search space within `A`.

3. **The Partition Logic**:
   - **Indices `i` and `j`**: We calculate `i` as the midpoint of `A` (`(l + r) // 2`) and `j` as the complementary index in `B` (`half - i - 2`). The `-2` accounts for zero-based indexing.
   - **Partition Elements**:
     - `Aleft` and `Aright` are the elements immediately to the left and right of the partition in `A`.
     - `Bleft` and `Bright` are the same for `B`.
   - We handle edge cases where the partition is at the extreme ends by assigning `-infinity` or `infinity` accordingly.

4. **Checking If Partition Is Correct**:
   - We verify if `Aleft <= Bright` and `Bleft <= Aright`. If this condition holds, it means we've found the correct partition.
   - **Calculating the Median**:
     - **Odd Total Length**: If the combined length is odd, the median is the minimum of `Aright` and `Bright`.
     - **Even Total Length**: If even, it's the average of the maximum of `Aleft` and `Bleft`, and the minimum of `Aright` and `Bright`.

5. **Adjusting the Search Space**:
   - If `Aleft > Bright`, it means we've partitioned `A` too far to the right, so we move `r` to `i - 1`.
   - If `Bleft > Aright`, we've partitioned `A` too far to the left, so we move `l` to `i + 1`.

6. **Iterating**: We repeat the process until we find the correct partition, which we will because each adjustment narrows the search space.

**Why This Works**:

By partitioning the arrays this way, we're effectively ordering the combined arrays without actually merging them. The left partitions contain the smaller half of numbers, and the right partitions contain the larger half. This approach ensures an O(log min(n, m)) time complexity since we're discarding half of the search space with each iteration.


By the way, it's pretty cool how this method avoids merging arrays altogether, right? Understanding this algorithm can be a game-changer for tackling other complex problems that require efficient search strategies. If you're up for it, exploring how this approach can be adapted to find other percentiles might be an exciting next step!



---

Similar code, improved readablility and simplified by ChatGPT.     

```python
# Time Complexity: O(log(min(n, m)))

class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        # Assign shorter names for easy reference
        A, B = nums1, nums2
        
        # Ensure A is the smaller array to optimize binary search
        if len(A) > len(B):
            A, B = B, A

        total = len(A) + len(B)   # Total number of elements
        half = total // 2         # Midpoint for median

        l, r = 0, len(A)          # Binary search boundaries in A

        while True:
            i = (l + r) // 2      # Partition index in A
            j = half - i          # Complementary partition in B

            # Elements just left and right of partition in A
            Aleft = A[i - 1] if i > 0 else float('-inf')
            Aright = A[i] if i < len(A) else float('inf')

            # Elements just left and right of partition in B
            Bleft = B[j - 1] if j > 0 else float('-inf')
            Bright = B[j] if j < len(B) else float('inf')

            # Check if partitions are correct
            if Aleft <= Bright and Bleft <= Aright:
                # Found the median
                if total % 2:
                    # Odd total length, median is min of right sides
                    return min(Aright, Bright)
                else:
                    # Even total length, median is average of middle two
                    return (max(Aleft, Bleft) + min(Aright, Bright)) / 2
            elif Aleft > Bright:
                # Move search window left in A
                r = i - 1
            else:
                # Move search window right in A
                l = i + 1
```

## Notes

We do `j = half - i` because elements from `0 to i-1` in A and `0 to j-1` in B 
must be equal to the half of total elements. We need median so once correct
half-half partitions are determined we just have to take the **i**th and **j**th
values and use them for median.




## Resources

[Binary Search : Median of two sorted arrays of different sizes | Tushar Roy](https://www.youtube.com/watch?v=LPFhl65R7ww):
This video has good example to make you understand the intuition.      
[Median of Two Sorted Arrays - Binary Search - Leetcode 4 | Neetcode](https://www.youtube.com/watch?v=q6IEA26hvXc):
The code above is taken from this video, it has python code and explains well but the examples do not cover the concept well enough. So, watch Tushar's video first.



## Break Down the Code with Example

Let's break down the code step by step using a concrete example. By walking through how the algorithm works with actual numbers, it'll become much clearer why we're doing what we're doing.

---

### **Example Arrays**

Let's consider these two sorted arrays:

```python
nums1 = [1, 3, 8, 9, 15]
nums2 = [7, 11, 18, 19, 21, 25]
```

- **Array A**: `[1, 3, 8, 9, 15]` (length 5)
- **Array B**: `[7, 11, 18, 19, 21, 25]` (length 6)

Our task is to find the median of the combined sorted arrays.

---

### **Step-by-Step Execution**

#### **1. Initial Setup**

```python
A, B = nums1, nums2

# Ensure A is the smaller array
if len(A) > len(B):
    A, B = B, A
```

- We assign `A` and `B` to `nums1` and `nums2`.
- Since `len(A) = 5` and `len(B) = 6`, we don't swap them.
- This ensures that we perform binary search on the smaller array `A` for efficiency.

#### **2. Calculating Total Length and Half Point**

```python
total = len(A) + len(B)  # total = 11
half = total // 2        # half = 5
```

- **Total elements**: 5 (in `A`) + 6 (in `B`) = **11**
- **Half point**: `11 // 2 = 5`
- The `half` variable helps us partition the arrays such that the combined left halves contain half of the elements.

#### **3. Initializing Binary Search Bounds**

```python
l, r = 0, len(A)  # l = 0, r = 5
```

- Left (`l`) and right (`r`) pointers for binary search on array `A`.

#### **4. First Iteration of Binary Search**

```python
i = (l + r) // 2    # i = (0 + 5) // 2 = 2
j = half - i        # j = 5 - 2 = 3
```

- **Partition indices**:
  - `i` partitions `A` at index **2**.
  - `j` partitions `B` at index **3**.

```python
Aleft = A[i - 1] if i > 0 else float('-inf')  # Aleft = A[1] = 3
Aright = A[i] if i < len(A) else float('inf')  # Aright = A[2] = 8

Bleft = B[j - 1] if j > 0 else float('-inf')  # Bleft = B[2] = 18
Bright = B[j] if j < len(B) else float('inf')  # Bright = B[3] = 19
```

- **Left and right elements around the partitions**:
  - `Aleft` (A left) = **3**
  - `Aright` (A right) = **8**
  - `Bleft` (B left) = **18**
  - `Bright` (B right) = **19**

**Checking Partition Correctness**:

```python
if Aleft <= Bright and Bleft <= Aright:
    # Correct partition found
elif Aleft > Bright:
    r = i - 1
else:
    l = i + 1
```

- **Condition**: Is `Aleft <= Bright` and `Bleft <= Aright`?
  - `3 <= 19` (True)
  - `18 <= 8` (False)
- Since `Bleft > Aright` (`18 > 8`), we need to move `l` to `i + 1`:

```python
l = i + 1  # l = 2 + 1 = 3
```

**Explanation**:

- We have too many small elements on the left side of `A`. We need to include more elements from `A` in the left partition, so we move `l` to the right.

---

#### **5. Second Iteration of Binary Search**

```python
i = (l + r) // 2    # i = (3 + 5) // 2 = 4
j = half - i        # j = 5 - 4 = 1
```

- **Partition indices**:
  - `i` partitions `A` at index **4**.
  - `j` partitions `B` at index **1**.

```python
Aleft = A[i - 1] if i > 0 else float('-inf')  # Aleft = A[3] = 9
Aright = A[i] if i < len(A) else float('inf')  # Aright = A[4] = 15

Bleft = B[j - 1] if j > 0 else float('-inf')  # Bleft = B[0] = 7
Bright = B[j] if j < len(B) else float('inf')  # Bright = B[1] = 11
```

- **Left and right elements around the partitions**:
  - `Aleft` (A left) = **9**
  - `Aright` (A right) = **15**
  - `Bleft` (B left) = **7**
  - `Bright` (B right) = **11**

**Checking Partition Correctness**:

- **Condition**: Is `Aleft <= Bright` and `Bleft <= Aright`?
  - `9 <= 11` (True)
  - `7 <= 15` (True)
- Both conditions are **True**; we've found the correct partition.

---

#### **6. Calculating Median**

Since the total number of elements is **odd** (`11`), the median is the minimum of the right elements:

```python
return min(Aright, Bright)  # min(15, 11) = 11
```

- **Median**: **11**

---

### **Why We're Doing These Steps**

- **Binary Search on Smaller Array**: Searching the smaller array minimizes the number of iterations, enhancing efficiency.

- **Partitioning Logic**:

  - We aim to partition `A` and `B` such that:
    - The total elements in the left partitions equal the total elements in the right partitions (or differ by one if the total number is odd).
    - All elements in the left partitions are less than or equal to all elements in the right partitions.

- **Adjusting `l` and `r`**:

  - If `Aleft > Bright`, it means there are too many large elements on the left side of `A`. We need to move `r` left to reduce `i`.
  - If `Bleft > Aright`, there are too many small elements on the left side of `B`. We need to move `l` right to increase `i`.

- **Handling Edge Cases**:

  - We use `float('-inf')` and `float('inf')` to handle situations where the partition index is at the boundaries of the array, simplifying comparisons.

---

### **Visual Representation**

Let's visualize the correct partition:

```
Array A: [1, 3, 8, 9 | 15]
                      ↑ i = 4

Array B: [7 | 11, 18, 19, 21, 25]
         ↑ j = 1
```

- **Left Partition**:
  - `A`: `[1, 3, 8, 9]`
  - `B`: `[7]`
- **Right Partition**:
  - `A`: `[15]`
  - `B`: `[11, 18, 19, 21, 25]`
- All elements in left partitions (`1, 3, 7, 8, 9`) are less than or equal to those in the right partitions (`11, 15, 18, 19, 21, 25`).

---

### **Understanding Edge Cases**

- **When `i = 0` or `i = len(A)`**:
  - If `i = 0`, it means there are no elements on the left side of `A`; we set `Aleft = float('-inf')`.
  - If `i = len(A)`, there are no elements on the right side of `A`; we set `Aright = float('inf')`.

- **This ensures that comparisons like `Aleft <= Bright` and `Bleft <= Aright` work correctly, even when partitions are at array boundaries.**

---

### **Additional Example (Even Total Number of Elements)**

Let's take arrays with an even total number of elements:

```python
nums1 = [1, 2]
nums2 = [3, 4]
```

- **Total elements**: 4 (even)
- **Expected median**: (2 + 3) / 2 = **2.5**

**Steps**:

1. **Initial Setup**:

   - `A = [1, 2]`, `B = [3, 4]`
   - `total = 4`, `half = 2`
   - `l = 0`, `r = 2`

2. **First Iteration**:

   - `i = (0 + 2) // 2 = 1`
   - `j = 2 - 1 = 1`
   - `Aleft = A[0] = 1`, `Aright = A[1] = 2`
   - `Bleft = B[0] = 3`, `Bright = B[1] = 4`
   - `Aleft <= Bright`? `1 <= 4` (True)
   - `Bleft <= Aright`? `3 <= 2` (False)
   - Since `Bleft > Aright`, move `l` to `i + 1 = 2`

3. **Second Iteration**:

   - `i = (2 + 2) // 2 = 2`
   - `j = 2 - 2 = 0`
   - `Aleft = A[1] = 2`, `Aright = float('inf')` (since `i = len(A)`)
   - `Bleft = float('-inf')` (since `j = 0`), `Bright = B[0] = 3`
   - `Aleft <= Bright`? `2 <= 3` (True)
   - `Bleft <= Aright`? `-inf <= inf` (True)
   - Correct partition found.

**Calculating Median**:

- Since total number is even, median is average of max of left elements and min of right elements:

```python
median = (max(Aleft, Bleft) + min(Aright, Bright)) / 2
median = (max(2, -inf) + min(inf, 3)) / 2
median = (2 + 3) / 2 = 2.5
```

- **Median**: **2.5**

---

### **Intuition Behind the Algorithm**

- **Avoiding Merge**: Merging two arrays would take O(n + m) time. This algorithm finds the median in O(log min(n, m)) time by using binary search.

- **Balancing Left and Right Halves**: By finding the correct partition, we're ensuring the left half contains all elements less than or equal to the right half.

- **Binary Search Advantage**: Each iteration narrows down the search space by half, leading to a logarithmic time complexity.

---

### **Metaphor to Understand the Process**

Think of merging two queues of people lined up by height (shortest to tallest). Instead of merging the queues to find the person in the middle, we're finding a point in each queue such that everyone before that point in both queues combined is shorter than everyone after that point. We're adjusting where we "cut" the lines (partitions) until this condition is met.

---

### **Why Are We Using `float('-inf')` and `float('inf')`?**

- They act as sentinels to handle edge cases smoothly.
- When the partition is at the very beginning or end of an array, these values ensure comparisons don't fail due to index errors or incorrect assumptions about missing elements.

---

### **Key Takeaways**

- **Efficiency**: By using binary search, we're finding the median without unnecessary computations.
- **Robustness**: The algorithm handles both even and odd total lengths and manages edge cases gracefully.
- **Scalability**: This approach is effective even for large arrays where merging would be impractical.

---

Feel free to dive deeper into any part of this explanation or ask about other scenarios. Understanding this algorithm thoroughly can significantly boost your problem-solving skills in algorithm design and optimization!



## Test cases for Dry-Run

Here are some examples and edge cases to test the provided code for finding the median of two sorted arrays:

### **Examples to Test**

1. **Basic Test Case (Odd Total Elements)**
   ```python
   nums1 = [1, 3, 8, 9, 15]
   nums2 = [7, 11, 18, 19, 21, 25]
   ```

2. **Basic Test Case (Even Total Elements)**
   ```python
   nums1 = [1, 2]
   nums2 = [3, 4]
   ```

3. **Arrays of Same Length**
   ```python
   nums1 = [1, 3, 5]
   nums2 = [2, 4, 6]
   ```

4. **One Array is Empty**
   ```python
   nums1 = []
   nums2 = [1, 2, 3, 4, 5]
   ```

### **Edge Cases**

1. **Single Element in Each Array**
   ```python
   nums1 = [1]
   nums2 = [2]
   ```

2. **Single Array**
   ```python
   nums1 = [1]
   nums2 = []
   ```

3. **Arrays with Different Ranges**
   ```python
   nums1 = [1, 5, 9]
   nums2 = [10, 15, 20]
   ```

4. **All Elements are Identical**
   ```python
   nums1 = [2, 2, 2]
   nums2 = [2, 2, 2]
   ```

5. **Large Numbers of Elements (Performance Test)**
   ```python
   nums1 = list(range(1, 10001, 2))  # Odd numbers up to 10000
   nums2 = list(range(2, 10002, 2))  # Even numbers up to 10000
   ```

6. **Smallest and Largest Possible Integers**
   ```python
   nums1 = [float('-inf'), 1, 2]
   nums2 = [3, 4, float('inf')]
   ```

---

### **Manual Dry Run**

By manually dry running these test cases, you can understand how the algorithm partitions the arrays, adjusts the search bounds, and calculates the median. You can observe how the binary search efficiently narrows down the search space and handles different edge cases.

Feel free to use these examples and let me know if you have any questions or need further explanations!