# 39. Combination Sum

The backtracking code is mind-fuck! 

```python
class Solution:
    def combinationSum(self, candidates, target):
        def dfs(start, path, target):
            if target == 0:
                # If we've reached the target, add the current path to results
                result.append(list(path))
                return
            for i in range(start, len(candidates)):
                if candidates[i] > target:
                    # No need to continue if the candidate exceeds the target
                    break
                # Include the candidate and continue searching
                path.append(candidates[i])
                dfs(i, path, target - candidates[i])
                path.pop()
        
        candidates.sort()  # Sort candidates to improve efficiency
        result = []
        dfs(0, [], target)
        return result

# Example usage:
solution = Solution()
candidates = [2, 3, 6, 7]
target = 7
print("Combinations:", solution.combinationSum(candidates, target))
# Output: [[2, 2, 3], [7]]
```


We have the example above `[2, 3, 6, 7]`.    
When we do `dfs(i, path, target - candidates[i])` that means we are including
the on which `i` is pointing. For simplicity, we assume that `i=2` means it
is point to `6`. This means there will a DFS run where `6` will be part of the
`path` and we already do the `target - candidates[i]` when ship the DFS.    

What you need to understand is that the DFS run above is separate! That run
will do its thing and we don't care about it. What we do next is to skip the `6`.
That's exactly, the code `path.pop()` is doing. We remove the `6` from `path`,
which honestly does nothing. The magic happens when we go back to the loop.
The loop will do `i++` and the `i=3` will point towards `7`. 
Now, since we removed the `6` from the path previously, and we only *shipped* 
the DFS previously using `dfs(i, path, target - candidates[i])`, notice how we
did not alter the target before, we just *shipped* the new target *if* `6` were
included.
Now, the path may look like this: `[2,3]` because we removed `6`. Now, the 
`path.append(candidates[i])` will add `7` and make the path `[2,3,7]`. This `path`
variable is basically used to add into the result, it is of no use to the 
actual function of the algorithm or logic. The **core** of the algoritm and code
lies in `dfs(i, path, target - candidates[i])` where we do not modify the 
target variable instead *ship* a new instance of DFS.



### Explanation of Approach:

1. **Sorting the Candidates**: We sort the candidates array to enhance efficiency. This allows us to stop further exploration as soon as we encounter a candidate that exceeds the current target.
2. **Base Case**: If the target becomes zero, we add the current path to the results as it represents a valid combination.
3. **Backtracking**: We add a candidate to the current path and recursively explore further by reducing the target. After exploring, we remove the last candidate (backtrack) and try the next candidate.

### Time & Space Complexity:
- **Time Complexity**: O(N^T/M), where N is the number of candidates, T is the target value, and M is the minimum value in candidates. This represents the complexity of exploring all combinations.
- **Space Complexity**: O(T/M) for the recursion stack and storing the valid combinations.
