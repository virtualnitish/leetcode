# 787. Cheapest Flights Within K Stops

```python
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        dist = [float("inf")] * n
        # starting from src
        dist[src] = 0
        tmp = []
        # Only k stops are allowed
        for _ in range(k+1):
            ## Same edges should not be relaxed multiple times
            ## with each relaxation we add a new node
            ## hence only k times we'll relax 
            tmp = dist.copy()
            for u,v,w in flights:
                ## Find the min value for current iteration
                ## tmp[v] is compared with previous iter's dist[u]
                if dist[u] != float('inf') and dist[u] + w < tmp[v]:
                    ## To make sure to use last iteration's distance
                    ## dist[u] is used
                    tmp[v] = dist[u] + w
            dist = tmp.copy()
        return dist[dst] if dist[dst] != float('inf') else -1
```

**Time Complexity:** O(kE) where k is number of stops and E is the number of
                     flights.   
**Space Complexity:** O(n) where n is the number of distinct source/destinations.  


The code is a modified version of Bellman-Ford's algorithm.   


Why `k+1` in `for _ in range(k+1)`?   
Because between `k` stops there are `k+1` edges and they all need to be *relaxed*.

In the example below, 3 stops between *Source* and *Destination* have 4 edges.

```
                                                              
                                                              
  [Source]â”€â”€â”€â–º Stop1â”€â”€â”€â–º Stop2â”€â”€â”€â”€â–º Stop3â”€â”€â”€â”€â–º [DESTINATION]   
                                                              
                                                              
```

---

## Same but detailed solution

```python
class Solution:
   def findCheapestPrice(
      self, n: int, flights: List[List[int]], src: int, dst: int, k: int
   ) -> int:
      # Initialize prices to reach each node as infinity
      prices = [float("inf")] * n
      # The price to reach the source node is 0
      prices[src] = 0

      # Iterate up to k+1 times (k stops means k+1 edges)
      for i in range(k + 1):
         # Create a temporary copy of prices to store updates for this iteration
         tmpPrices = prices.copy()

         # Iterate over all flights
         for s, d, p in flights:  # s=source, d=dest, p=price
            # If the source node has not been reached yet, skip this flight
            if prices[s] == float("inf"):
               continue
            # If a cheaper price to reach destination d is found, update tmpPrices
            if prices[s] + p < tmpPrices[d]:
               tmpPrices[d] = prices[s] + p
         # Update prices with the new values from tmpPrices
         prices = tmpPrices

      # If the destination node is still infinity, return -1 (no such route)
      return -1 if prices[dst] == float("inf") else prices[dst]
```


The solution uses a bit modified version of Bellman-Ford Algorithm

### Why Use `tmpPrices`:
1. **Limited Iterations (`k+1` Iterations)**:
   - The problem requires finding the cheapest flight price with at most `k` stops, meaning we should only consider up to `k+1` edge relaxations (where `k+1` includes the initial source node).

2. **Preventing Premature Updates**:
   - In the given problem, each iteration represents considering flights with a certain number of stops. By using a temporary list `tmpPrices`, the algorithm ensures that all flights in the current iteration are processed based on the prices from the previous iteration, not affecting each other within the same iteration.
   - This distinction ensures that flights considered in the current iteration do not influence others in the same iteration cycle, which might otherwise lead to incorrect results.

### Difference from Original Bellman-Ford:
- **Original Bellman-Ford**: In the traditional Bellman-Ford algorithm, all vertices are processed for `V-1` iterations (where `V` is the number of vertices), allowing all shortest paths to converge. Since each vertex update is propagated in sequence, there's no need for a temporary list as all edges are relaxed multiple times, ensuring convergence.
- **Modified for K Stops**: The modified version considers flights with at most `k` stops. To ensure flights from the current iteration (number of stops) do not influence others prematurely, a temporary list `tmpPrices` is used to store updated prices for the next iteration.

### Step-by-Step Explanation of the Code:
1. **Initialization**:
   - `prices[src] = 0`: Sets the price to reach the source vertex to `0`.
   - `prices = [float("inf")] * n`: Initializes prices to reach all other vertices as infinity.

2. **Iterate `k+1` times**:
   - Outer loop: Iterates up to `k+1` times to relax edges for up to `k` stops.
   - `tmpPrices = prices.copy()`: Creates a copy of the current prices to ensure updates within the current iteration do not affect other flights in the same iteration.

3. **Relaxation**:
   - Inner loop: Iterates over all flights (edges) and updates the `tmpPrices` list if a cheaper price is found via the current flight.
   - `if prices[s] + p < tmpPrices[d]`: Updates the price to reach destination `d` if a cheaper price is found through source `s`.

4. **Update Prices**:
   - `prices = tmpPrices`: After processing all flights for the current iteration, updates the `prices` list with the new prices for the next iteration.

5. **Result**:
   - `return -1 if prices[dst] == float("inf") else prices[dst]`: Returns the final cheapest price to reach the destination within `k` stops or `-1` if no such price exists.

By using `tmpPrices`, the algorithm ensures that the current iteration's updates are only applied after all flights have been considered, preserving the integrity of the constraints (`k` stops).


---

Absolutely! Hereâ€™s a clean set of notes you can keep for quick reference, focused on understanding why we use `tmp` in the context of the Leetcode 787 problem, along with a brief refresher on the Bellman-Ford algorithm.

---

# ðŸ§­ Bellman-Ford Refresher

**Purpose:**  
Find the shortest path from a source to all vertices in a weighted graph, even with negative weights.

**Core Steps:**
1. Initialize `dist[src] = 0`, and all others to `âˆž`.
2. Repeat `n âˆ’ 1` times: for each edge `(u â†’ v, weight w)`, update:
   ```
   if dist[u] + w < dist[v]:
       dist[v] = dist[u] + w
   ```
3. (Optional) Do one extra pass to detect negative cycles: if any distance still improves, there's a cycle.

âœ… **Updates happen in-place**, which is fine when edge count isnâ€™t constrained.

---

# ðŸ›¬ Why Do We Use `tmp` in Leetcode 787 (with â‰¤ K Stops)?

In 787, we **limit the number of edges used to at most `K + 1`**, which is very different from classic Bellman-Ford.

To achieve this:
- You run the relaxation loop `K + 1` times.
- But critically: **each pass may only consider one more edge than the previous**.
- That means you must **avoid using updated distances from the same iteration** â€” or you might chain multiple edges in a single pass.

âœ… Solution: **Use a snapshot `tmp = dist.copy()` at the beginning of each iteration.**

---

# ðŸ§ª The Critical Example: What Goes Wrong Without `tmp`

### Graph:

```
0 â†’ 1 (cost 1)
1 â†’ 2 (cost 2)
2 â†’ 3 (cost 3)
```

### Settings:
- `src = 0`, `dst = 3`, `K = 1` (so only 2 edges max allowed)

---

## âŒ Case A: In-place updates (Incorrect)

**Iteration 0:**
- `dist[1]` = 0 + 1 = 1
- `dist[2]` = 1 + 2 = 3  â† uses the new `dist[1]` from this same pass
- `dist[3]` = 3 + 3 = 6  â† again, using freshly updated `dist[2]`

Now youâ€™ve used **three edges** in one pass â€” which violates the `K` constraint. This result is invalid.

---

## âœ… Case B: With `tmp = dist.copy()` (Correct)

Each iteration uses the **snapshot from the previous round**:

**Iteration 0 (paths with â‰¤1 edge):**
- Relax 0â†’1 using `dist[0]` â†’ `tmp[1] = 1`
- Skips 1â†’2, 2â†’3 (since `dist[1]`, `dist[2]` still âˆž)

**Iteration 1 (paths with â‰¤2 edges):**
- Relax 1â†’2 using `dist[1] = 1` â†’ `tmp[2] = 3`
- Skips 2â†’3 (still `dist[2] = âˆž`)

Result: `dist[3] = âˆž` â†’ no valid path within 2 edges â†’ correct return `-1`.

---

# ðŸ§© Takeaway

- Bellman-Ford doesnâ€™t constrain the number of edges used per iteration â€” fine for general shortest paths.
- Leetcode 787 **must** control the edge count per iteration.
- So we **must isolate each roundâ€™s progress using `tmp`**, ensuring only one edge per layer.

ðŸ” Think of it like layers:
- Layer 0: 0 edges
- Layer 1: 1 edge
- ...
- Layer K+1: up to `K+1` edges

Each layer builds only from the one beneath it, not from itself.



---

## Explain the overall logic

### 1. What Standard Bellman-Ford Does

* **Technical:** It's a shortest-path algorithm that finds the cheapest path from a single source to all other nodes in a graph. Its core operation is "relaxation." It iterates `V-1` times (where `V` is the number of nodes). After `i` iterations, it's guaranteed to have found the shortest path that uses **at most `i` edges**.
* **Layman:** Think of it as a "price update" system. In Round 1, it finds all the cheapest 1-flight trips. In Round 2, it uses the 1-flight prices to find the cheapest 2-flight trips. It keeps doing this until it has found the cheapest-possible trip, no matter how many flights.

---

### 2. Why the `k+1` Loop?

* **Technical:** The problem asks for the cheapest price with at most `k` **stops**. A path with `k` stops has `k+1` **edges** (e.g., A -> B -> C is 1 stop, 2 edges). Since the Bellman-Ford property guarantees the shortest path with at most `i` edges after `i` iterations, we just run the loop `k+1` times.
* **Layman:** We don't want the *absolute* cheapest path (which might have 10 stops). We *only* care about paths up to a certain length. We are "stopping" the algorithm early. If `k=1` stop, we run it for `k+1 = 2` rounds to find the best 2-flight path.

---

### 3. Why the `copy` is Critical (The Modification)

This is the most important part. Your code's `dist_cp` is the key modification.

* **Technical (The "Why"):** We must strictly enforce the `i`-edge limit at each iteration. Iteration `i` must **only** build its new paths (`dist_cp`) by using the results from the *previous* iteration `i-1` (the `dist` array).
    * `dist` = Holds the cheapest prices using at most **`i-1`** edges. (READ-ONLY)
    * `dist_cp` = Holds the cheapest prices we are *building* for at most **`i`** edges. (WRITE-ONLY)
    * If we updated `dist` directly, we would "contaminate" our `i-1` results with `i` results *in the middle of the same loop*, breaking the logic.

* **Layman (The Analogy):** Imagine you are baking a 2-layer cake.
    * `dist` is your **Finished Layer 1** (all 1-flight paths).
    * `dist_cp` is your **New Layer 2** (all 2-flight paths).
    * To make Layer 2, you must *only* use Layer 1. You can't take a piece of Layer 2 you just baked and use it to finish another part of Layer 2.
    * Using `dist_cp` means we read *only* from the finished `dist` (Layer 1) to build the *entire* new `dist_cp` (Layer 2). At the end of the round, we throw away the old `dist` and our `dist_cp` becomes the new, finished `dist` for the next round. This "freezes" the state and prevents contamination.

---

### 4. Example: What Happens if You DON'T Use a Copy

Let's use the same example:
* **Goal:** 0 to 3, with `k=1` (max 2 edges).
* **Correct Answer:** 60 (Path: `0->1->3`, 2 edges)
* **Paths:**
    * `0->1` (cost 10)
    * `1->3` (cost 50) <- The 2-edge solution
    * `1->2` (cost 10)
    * `2->3` (cost 10) <- Part of the 3-edge solution

Let's trace **Iteration 2** (for 2-edge paths) **WITHOUT** a copy:

1.  **Start of Iteration 2:**
    `dist = [0, 10, INF, INF]` (This is the result from Iteration 1, showing 1-edge paths)

2.  **We loop through flights and update `dist` live:**
    * ... (other flights) ...
    * **Flight `[1, 3, 50]`:**
        * `dist[1]` (10) + 50 = 60.
        * `dist[3]` is `INF`. So, 60 is cheaper.
        * **`dist` becomes `[0, 10, INF, 60]`**. (We just found the 2-edge path, which is good).
    * **Flight `[1, 2, 10]`:**
        * `dist[1]` (10) + 10 = 20.
        * `dist[2]` is `INF`. So, 20 is cheaper.
        * **`dist` becomes `[0, 10, 20, 60]`**. (We just found the 2-edge path `0->1->2`).
    * **Flight `[2, 3, 10]` (THE PROBLEM):**
        * The code checks `dist[2]`. It's no longer `INF`. It's **20** (which we *just* wrote in this same iteration).
        * It calculates `dist[2]` (20) + 10 = **30**.
        * `dist[3]` is 60. So, 30 is cheaper.
        * **`dist` becomes `[0, 10, 20, 30]`**.

3.  **End of Loop:** The algorithm returns `dist[3]`, which is **30**.

This is wrong. It returned the price for the 3-edge path (`0->1->2->3`) because it "contaminated" the loop, using a 2-edge result (`dist[2]=20`) to immediately create a 3-edge path, all within the iteration meant to find 2-edge paths.