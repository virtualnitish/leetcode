# 300. Longest Increasing Subsequence

## 1. The Brute Force Method (DFS):

```python
def lengthOfLIS(self, nums: List[int]) -> int:
    def dfs(start: int) -> int:
        max_len = 1  # Each element is a subsequence of length 1
        # Explore all valid next elements to extend the subsequence
        for next in range(start + 1, len(nums)):
            if nums[next] > nums[start]:
                max_len = max(max_len, 1 + dfs(next))
        return max_len
    
    if not nums:
        return 0
    # Check all possible starting points and return the maximum
    return max(dfs(i) for i in range(len(nums)))
```

**Time Complexity:** **O(2^n)**  
- Explanation: In the worst case, the DFS explores all possible subsequences. For each element, there are two choices: either include it in the current subsequence or exclude it. This results in a binary tree of recursive calls with a depth of `n`, leading to exponential time complexity.

## 2. The Brute Force Method with Memoization:

```python
def lengthOfLIS(self, nums: List[int]) -> int:
    n = len(nums)
    if not n:
        return 0
    
    # Dictionary to store cached results
    cache = {}
    
    def dfs(start: int) -> int:
        # Return cached result if available
        if start in cache:
            return cache[start]
        
        max_len = 1
        # Explore all valid next elements to extend the subsequence
        for next in range(start + 1, n):
            if nums[next] > nums[start]:
                max_len = max(max_len, 1 + dfs(next))
        
        # Store the result in cache before returning
        cache[start] = max_len
        return max_len
    
    # Check all possible starting points and return the maximum
    return max(dfs(i) for i in range(n))
```

**Time Complexity:** **O(n^2)**  
- Explanation:  
  - The memoization ensures that each subproblem (starting at a specific index) is solved only once.  
  - There are `n` unique subproblems (one for each index), and each subproblem takes `O(n)` time to solve (due to the inner loop over the remaining elements).  
  - Thus, the total time complexity is **O(n^2)**.

## 3. The Dynamic Programming Solution:

```python
def lengthOfLIS(self, nums: List[int]) -> int:
    if not nums:
        return 0
    # dp[i] represents the length of the longest increasing subsequence ending at index i
    dp = [1] * len(nums)
    
    for i in range(len(nums)):
        for j in range(i):
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)  # Update if a longer subsequence is found
    
    return max(dp)
```

**Time Complexity:** **O(n^2)**  
- Explanation:  
  - The outer loop runs `n` times, and the inner loop runs up to `n` times for each iteration of the outer loop.  
  - For each element, the algorithm checks all previous elements to update the `dp` array, resulting in a total of **O(n^2)** operations.

### Approach

![DP Solution, skip value](images/0300.longest_increasing_subsequence-image.png)



## Summary of Time Complexities:
| Method                          | Time Complexity |
|---------------------------------|-----------------|
| Brute Force (DFS)               | O(2^n)          |
| Brute Force with Memoization    | O(n^2)          |
| Dynamic Programming             | O(n^2)          |
